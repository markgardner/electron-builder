{
  "version": 3,
  "file": "promise.js",
  "sourceRoot": "",
  "sources": [
    "../src/promise.ts"
  ],
  "names": [],
  "mappings": ";;AAAA,2BAA2C,AAAU,AACrD,AAAC;AAAD,wBAAoB,AAAO,AAE3B,AAAmC,AACnC,AAAC;;AAAD,MAAM,AAAS,YAAG,AAAO,QAAC,AAAW,AAAC;AAEtC,2BAAkC,AAAY;AAC5C,AAAO,YAAC,AAAK,MAAC,QAAG,IAAC,CAAC,AAAK,MAAC,AAAK,SAAI,AAAK,AAAC,OAAC,AAAQ,AAAE,AAAC,AAAC;AACrD,AAAO,YAAC,AAAI,KAAC,CAAC,AAAC,AAAC,AAClB;AAAC;AAHe,QAAiB,oBAGhC,AAED,AAA6F;;AAC7F,wBAAqC,AAAqB,SAAE,AAA8C;;AACxG,YAAI,AAAM,SAAQ,AAAI;AACtB,YAAI,AAAC;AACH,AAAM,qBAAG,MAAM,AAAO,AACxB;AACA,UAAA,AAAK,AAAC,OAAC,AAAa,AAAC,eAAC,AAAC;AACrB,gBAAI,AAAC;AACH,sBAAM,AAAI,KAAC,AAAI,AAAC,AAClB;AACA,cAAA,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,sBAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC,AACnD;AAAC;AAED,kBAAM,AAAa,AACrB;AAAC;AAED,YAAI,AAAC;AACH,kBAAM,AAAI,KAAC,AAAK,AAAC,AACnB;AACA,UAAA,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,kBAAM,AAAS,AACjB;AAAC;AACD,AAAM,eAAC,AAAM,AACf;AAAC;;AAvBqB,QAAc,iBAuBnC;AAED,0BAAiC,AAAK;AACpC,gBAAY,AAAoB;YAAE,AAAO,gEAAW,AAAkB;;AACpE,YAAI,AAAC,IAAG,AAAO;AACf,YAAI,AAAC,IAAG,AAAC;AACT,AAAG,AAAC,aAAC,IAAI,AAAK,SAAI,AAAM,AAAC,QAAC,AAAC;AACzB,kBAAM,AAAM,SAAG,AAAS,YAAG,AAAC,AAAE,MAAG,AAAG;AACpC,AAAC,iBAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAM,MAAC,AAAK,AAC7D;AAAC;AACD,cAAM,AAAC,AAAC,AACV;AAAC,AACH,AAAC;;AAVY,QAAW,cAUvB;AAED,aAAoB,AAA6B;AAC/C,UAAM,AAAM,SAAiB,AAAE;AAC/B,AAAM,sBAAgB,QAAC,AAAG,IAAC,AAAQ,SAAC,AAAG,IAAC,AAAE,MAAI,AAAE,GAAC,AAAK,MAAC,AAAE,MAAI,AAAM,OAAC,AAAI,KAAC,AAAE,AAAC,AAAC,AAAC,AAAC,OAC5E,AAAI,KAAC;AACJ,AAAE,AAAC,YAAC,AAAM,OAAC,AAAM,WAAK,AAAC,AAAC,GAAC,AAAC;AACxB,kBAAM,AAAM,OAAC,AAAC,AAAC,AACjB;AAAC,AACD,AAAI,eAAC,AAAE,AAAC,IAAC,AAAM,OAAC,AAAM,SAAG,AAAC,AAAC,GAAC,AAAC;AAC3B,kBAAM,IAAI,AAAW,YAAC,AAAM,QAAE,AAAkB,AAAC,AACnD;AAAC,AACH;AAAC,AAAC,AACN,KATS;AASR;AAXe,QAAG,MAWlB",
  "sourcesContent": [
    "import { Promise as BluebirdPromise } from \"bluebird\"\r\nimport { red } from \"chalk\"\r\n\r\n//noinspection JSUnusedLocalSymbols\r\nconst __awaiter = require(\"./awaiter\")\r\n\r\nexport function printErrorAndExit(error: Error) {\r\n  console.error(red((error.stack || error).toString()))\r\n  process.exit(-1)\r\n}\r\n\r\n// you don't need to handle error in your task - it is passed only indicate status of promise\r\nexport async function executeFinally(promise: Promise<any>, task: (errorOccurred: boolean) => Promise<any>): Promise<any> {\r\n  let result: any = null\r\n  try {\r\n    result = await promise\r\n  }\r\n  catch (originalError) {\r\n    try {\r\n      await task(true)\r\n    }\r\n    catch (taskError) {\r\n      throw new NestedError([originalError, taskError])\r\n    }\r\n\r\n    throw originalError\r\n  }\r\n\r\n  try {\r\n    await task(false)\r\n  }\r\n  catch (taskError) {\r\n    throw taskError\r\n  }\r\n  return result\r\n}\r\n\r\nexport class NestedError extends Error {\r\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\r\n    let m = message\r\n    let i = 1\r\n    for (let error of errors) {\r\n      const prefix = \"Error #\" + i++ + \" \"\r\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\r\n    }\r\n    super(m)\r\n  }\r\n}\r\n\r\nexport function all(promises: Array<Promise<any>>): BluebirdPromise<any> {\r\n  const errors: Array<Error> = []\r\n  return BluebirdPromise.all(promises.map(it => it.catch(it => errors.push(it))))\r\n    .then(() => {\r\n      if (errors.length === 1) {\r\n        throw errors[0]\r\n      }\r\n      else if (errors.length > 1) {\r\n        throw new NestedError(errors, \"Cannot cleanup: \")\r\n      }\r\n    })\r\n}"
  ]
}
